---
title: Elixir Girls Guides Slackir App retrieving stored data
---
<h1>Retrieving from database</h1>
  <p> Note: we are going to be adding all these code into <code>lib/slackir_web/channels/random_channel.ex</code> </p>
  <p>Everytime when you refresh your page, you lose the message history and that is not ideal if you want to know what has been discussed.
  We have all these stored messages in our database, and we want to retrieve it when someone logs in. Therefore, we will need to retrieve these messages and display them in the chat dialog.</p>
  <h2>Perform a callback after join</h2>
  <p>Go to the <strong>join</strong> function, and add the line just below <code>if authorized?(payload) do</code></p>
  <p>We are going to send a message contaning our self <b>PID(Process Identifier)</b> as the first parameter. The second parameter is a message to run a function called <code>after_join</code>. This function is identified by an atom type.</p>

  <% code("elixir") do %>
  def join("random:lobby", payload, socket) do
    if authorized?(payload) do
      send self(), :after_join #<-- Add this line
      {:ok, socket}
    else
      {:error, %{reason: "unauthorized"}}
    end
  end
  <% end %>

<h4>What does send do?</h4>
<p><code>send</code> sends a message, <code>:after_join</code>, with it's PID generated by the function ,<code>self()</code>. We want to be able to run the after join task asynchronously. Lets look at how we should receive the <code>:after_join</code> message</p>
<h1>Receiving a message in a callback</h1>
<p>We now know that a message identified by the atom <code>:after_join</code> is being sent.
Phoenix provides us with a function called <strong>handle_info</strong> to be able to receive that message and do something with it.
Insert the following code after the <em>join</em> function </p>
  <% code("elixir") do %>
  def handle_info(:after_join, socket) do
    messages =
      Slackir.Conversations.list_messages()
      |> Enum.map(fn(m) -> %{message: m.message, name: m.name} end)

    push socket, "messages_history", %{messages: messages}
    {:noreply, socket}
  end
  <% end %>

  <h1>Retrieving all messages from our database</h1>
  <p>Phew, that looked like a lot is going on in the <code>handle_info</code> function. Lets breakdown the code to understand what is going on.</p>
  <p>
    As we have seen previously, context <code>Slackir.Conversations</code> provides us with many useful functions to communicate with the database. Thanks to <code>list_messages()</code> function we can retrieve all the messages from our database.
  </p>
  <p>
    We then, pipe the retrieved <b>messages</b> into a <code>map()</code> function provided by the <code>Enum</code> module.
    <code>map</code> applies this anonymous function <code>&(%{message: &1.message, name: &1.name})</code> onto every element in <b>messages</b>
  </p>
  <p><em>Note: Please ask your mentor to explain how <code>Enum.map</code> works if you are unsure about it :)</em></p>
  <p>
    There is of course the <b>&</b> operator that is used as a shorthand to convert the expression into a function. We are trying to format the messages that we have retrieved into a proper structure.
  </p>
  <h1>Passing the messages back to the browser</h1>
  <p>Finally, we want to push our list of messages to the socket via the <strong>push</strong> function.</p>
  <p>We are using <em>push</em> instead of <em>broadcast</em>, because we only want to display it to the current user that has just joined the channel</P>

  <h1>Render the messages in the browser</h1>
  <p>Add the below code to the <code>assets/js/socket.js</code> file</p>
  <% code("js") do %>
    channel.on('messages_history', messages => {
      let messages_list = messages["messages"];

      messages_list.forEach( function(msg) {
        list.append(`<b>${msg["name"] || 'Anonymous'}:</b> ${msg["message"]}<br>`);
        list.prop({scrollTop: list.prop("scrollHeight")});
      });
    });
  <% end %>
  <p>This is the final step, really. We need display the messages in our browser by iterating through our list
  You should have the history of messages displayed to you when you join the channel. Try opening multiple tabs connecting to http://127.0.0.1/4000
  <p>You will be able to see that all the messages gets rendered everytime you join</p>
